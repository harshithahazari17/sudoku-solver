<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Sudoku C++ → HTML + Live Solver</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; margin: 20px; color: #222; }
    h1 { margin-bottom: 8px; }
    .container { display: grid; grid-template-columns: 1fr 520px; gap: 20px; }
    pre { background:#f6f8fa; padding:12px; border-radius:6px; overflow:auto; max-height:520px; }
    code { font-family: "Courier New", monospace; font-size:13px; white-space:pre; }
    button { margin-right:8px; padding:8px 12px; border-radius:6px; border:1px solid #bbb; background:#fff; cursor:pointer; }
    button:hover { box-shadow:0 1px 3px rgba(0,0,0,0.08); }
    .controls { margin-bottom:10px; }
    .grid { display:grid; grid-template-columns: repeat(9, 40px); gap:4px; }
    .grid input { width:40px; height:36px; text-align:center; font-size:16px; border:1px solid #999; border-radius:4px; }
    .grid .thick-right { border-right:2px solid #333; }
    .grid .thick-bottom { border-bottom:2px solid #333; }
    .btn-row { margin-top:10px; }
    .note { font-size:13px; color:#555; margin-top:10px; }
    .left-panel { display:flex; flex-direction:column; }
  </style>
</head>
<body>

  <h1>Sudoku C++ → HTML (with Live Solver)</h1>
  <p>Below is your exact C++ source shown, plus a web-based Sudoku solver that uses the same backtracking approach.</p>

  <div class="container">
    <!-- Left: show C++ code with copy/download -->
    <div class="left-panel">
      <div class="controls">
        <button id="copyBtn">Copy C++ Code</button>
        <button id="downloadBtn">Download .cpp</button>
      </div>

      <pre><code id="cppCode">// Original C++ Sudoku solver (exact code)
#include &lt;iostream&gt;
using namespace std;

#define N 9  // Size of the Sudoku grid

// Function to print the Sudoku grid
void printGrid(int grid[N][N]) {
    cout &lt;&lt; "\nSolved Sudoku:\n";
    for (int row = 0; row &lt; N; row++) {
        for (int col = 0; col &lt; N; col++) {
            cout &lt;&lt; grid[row][col] &lt;&lt; " ";
        }
        cout &lt;&lt; endl;
    }
}

// Function to check if placing num is valid at grid[row][col]
bool isSafe(int grid[N][N], int row, int col, int num) {
    // Check row
    for (int x = 0; x &lt; N; x++)
        if (grid[row][x] == num)
            return false;

    // Check column
    for (int x = 0; x &lt; N; x++)
        if (grid[x][col] == num)
            return false;

    // Check 3x3 subgrid
    int startRow = row - row % 3;
    int startCol = col - col % 3;
    for (int i = 0; i &lt; 3; i++)
        for (int j = 0; j &lt; 3; j++)
            if (grid[i + startRow][j + startCol] == num)
                return false;

    return true;
}

// Recursive function to solve the Sudoku using backtracking
bool solveSudoku(int grid[N][N], int row, int col) {
    // If reached end, puzzle is solved
    if (row == N - 1 && col == N)
        return true;

    // Move to next row
    if (col == N) {
        row++;
        col = 0;
    }

    // Skip already filled cells
    if (grid[row][col] != 0)
        return solveSudoku(grid, row, col + 1);

    for (int num = 1; num &lt;= 9; num++) {
        if (isSafe(grid, row, col, num)) {
            grid[row][col] = num;  // Place number

            if (solveSudoku(grid, row, col + 1))
                return true;

            grid[row][col] = 0;  // Backtrack
        }
    }
    return false;
}

int main() {
    int grid[N][N];

    cout &lt;&lt; "Enter the Sudoku puzzle (use 0 for empty cells):\n";
    for (int i = 0; i &lt; N; i++) {
        for (int j = 0; j &lt; N; j++) {
            cin &gt;&gt; grid[i][j];
        }
    }

    if (solveSudoku(grid, 0, 0))
        printGrid(grid);
    else
        cout &lt;&lt; "\nNo solution exists for the given Sudoku.\n";

    return 0;
}
</code></pre>

    </div>

    <!-- Right: live solver UI -->
    <div>
      <h3>Live Sudoku Solver (same backtracking algorithm in JS)</h3>
      <div class="note">Enter digits 1–9; use 0 or leave blank for empty cells.</div>

      <div style="margin-top:10px;">
        <div class="grid" id="sgrid"></div>

        <div class="btn-row">
          <button id="solveBtn">Solve</button>
          <button id="clearBtn">Clear</button>
          <button id="fillSampleBtn">Fill Sample</button>
          <button id="readCppBtn">Load from C++ Input</button>
        </div>

        <div class="note">You can also paste 81 numbers (row-major, spaces/newlines allowed) into the prompt after clicking "Load from C++ Input".</div>
      </div>
    </div>
  </div>

  <script>
    // The raw C++ code string (exact) for download
    const cppText = document.getElementById('cppCode').innerText;

    // Copy button behavior
    document.getElementById('copyBtn').addEventListener('click', () => {
      navigator.clipboard.writeText(cppText).then(() => {
        alert('C++ code copied to clipboard.');
      }).catch(() => alert('Copy failed.'));
    });

    // Download .cpp file
    document.getElementById('downloadBtn').addEventListener('click', () => {
      const blob = new Blob([cppText], {type: 'text/plain'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'sudoku_solver.cpp';
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    });

    // Build the 9x9 input grid
    const gridEl = document.getElementById('sgrid');
    const inputs = [];
    for (let r = 0; r < 9; r++) {
      for (let c = 0; c < 9; c++) {
        const inp = document.createElement('input');
        inp.type = 'text';
        inp.maxLength = 1;
        inp.inputMode = 'numeric';
        inp.pattern = '[0-9]';
        inp.dataset.r = r;
        inp.dataset.c = c;
        // thicker borders for 3x3 boxes
        if ((c+1) % 3 === 0 && c !== 8) inp.classList.add('thick-right');
        if ((r+1) % 3 === 0 && r !== 8) inp.classList.add('thick-bottom');
        gridEl.appendChild(inp);
        inputs.push(inp);
        // allow arrow navigation
        inp.addEventListener('keydown', (e) => {
          const idx = inputs.indexOf(inp);
          if (e.key === 'ArrowRight') inputs[Math.min(inputs.length-1, idx+1)].focus();
          if (e.key === 'ArrowLeft') inputs[Math.max(0, idx-1)].focus();
          if (e.key === 'ArrowDown') inputs[Math.min(inputs.length-1, idx+9)].focus();
          if (e.key === 'ArrowUp') inputs[Math.max(0, idx-9)].focus();
        });
      }
    }

    // Helper: read grid into 2D array (integers)
    function readGrid() {
      const grid = Array.from({length:9}, () => Array(9).fill(0));
      for (let i = 0; i < 81; i++) {
        const v = inputs[i].value.trim();
        grid[Math.floor(i/9)][i%9] = v === '' ? 0 : parseInt(v) || 0;
      }
      return grid;
    }

    // Helper: write 2D array to inputs
    function writeGrid(grid) {
      for (let i = 0; i < 81; i++) {
        const r = Math.floor(i/9), c = i%9;
        inputs[i].value = grid[r][c] === 0 ? '' : String(grid[r][c]);
      }
    }

    // Check same constraints as C++ isSafe
    function isSafe(grid, row, col, num) {
      for (let x = 0; x < 9; x++) if (grid[row][x] === num) return false;
      for (let x = 0; x < 9; x++) if (grid[x][col] === num) return false;
      const startRow = row - row % 3;
      const startCol = col - col % 3;
      for (let i = 0; i < 3; i++)
        for (let j = 0; j < 3; j++)
          if (grid[startRow + i][startCol + j] === num) return false;
      return true;
    }

    // Backtracking solver (mirrors the C++ logic)
    function solveSudoku(grid, row=0, col=0) {
      if (row === 8 && col === 9) return true;
      if (col === 9) { row++; col = 0; }
      if (grid[row][col] !== 0) return solveSudoku(grid, row, col+1);

      for (let num = 1; num <= 9; num++) {
        if (isSafe(grid, row, col, num)) {
          grid[row][col] = num;
          if (solveSudoku(grid, row, col+1)) return true;
          grid[row][col] = 0;
        }
      }
      return false;
    }

    // Solve button
    document.getElementById('solveBtn').addEventListener('click', () => {
      const grid = readGrid();
      // Validate entries are 0..9
      for (let r=0;r<9;r++) for (let c=0;c<9;c++) {
        const v = grid[r][c];
        if (v < 0 || v > 9 || Number.isNaN(v)) { alert('Only digits 0-9 allowed'); return; }
      }
      const copy = grid.map(row => row.slice());
      if (solveSudoku(copy)) {
        writeGrid(copy);
        alert('Solved (using backtracking)');
      } else {
        alert('No solution exists for the given Sudoku.');
      }
    });

    // Clear button
    document.getElementById('clearBtn').addEventListener('click', () => {
      inputs.forEach(i => i.value = '');
    });

    // Fill sample puzzle (an example)
    document.getElementById('fillSampleBtn').addEventListener('click', () => {
      const sample = [
        [5,3,0,0,7,0,0,0,0],
        [6,0,0,1,9,5,0,0,0],
        [0,9,8,0,0,0,0,6,0],
        [8,0,0,0,6,0,0,0,3],
        [4,0,0,8,0,3,0,0,1],
        [7,0,0,0,2,0,0,0,6],
        [0,6,0,0,0,0,2,8,0],
        [0,0,0,4,1,9,0,0,5],
        [0,0,0,0,8,0,0,7,9]
      ];
      writeGrid(sample);
    });

    // Load from C++-style input prompt (enter 81 numbers, whitespace allowed)
    document.getElementById('readCppBtn').addEventListener('click', () => {
      const txt = prompt('Paste 81 numbers (use 0 for empties). Whitespace/newlines allowed:');
      if (!txt) return;
      const tokens = txt.trim().split(/\s+/).filter(Boolean);
      if (tokens.length !== 81) { alert('Please enter exactly 81 numbers. Found: ' + tokens.length); return; }
      const g = Array.from({length:9}, () => Array(9).fill(0));
      for (let i=0;i<81;i++){
        const n = parseInt(tokens[i]) || 0;
        g[Math.floor(i/9)][i%9] = n;
      }
      writeGrid(g);
    });

  </script>
</body>
</html>
